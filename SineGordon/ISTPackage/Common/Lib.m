(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



BeginPackage[$Library];
Needs["RiemannHilbert`"];
(*ReduceDimensionMatrix::usage="";
IntegrateMatrix::usage="";
ReduceDimensionIntegrateMatrix::usage="";*)
AddBasisElement::usage="";
Zoom::usage="";
Linspace::usage="";
Zipper::usage="";
RHPDerivative::usage="";
RHPNorm::usage="";
RHPNormCoordinate;
FindZerosVect;
RemoveEntries;
Trim;
cc;
SignChange;
TruncateMatrix;
Truncate::usage="Contour truncation routine.  This requires the sample function, see Setrsamp[].";
CreateDomains;
Adapt;
LineConjugate;
LineReverse;
mRHWellPosed;
MultFun;
InvFun;
MakeListFun;
ConjugateJumps;
ConjugateList;
RightMultiplyJumps;
LeftMultiplyJumps;
RightMultiplyList;
LeftMultiplyList;
MakeZeroFun;
TruncateArcsLines;
AdaptArcsLines;

Begin["Private`"];


(*ReduceDimensionMatrix[d_,n_]:=Inverse[TransformMatrix[d,n-1]].IdentityMatrix[n]\[LeftDoubleBracket];;-2,All\[RightDoubleBracket].TransformMatrix[n];
ReduceDimensionMatrix[f_]:=ReduceDimensionMatrix[f//Domain,f//Length];

IntegrateMatrix[d_,n_Integer]:=
ColumnMap[ChebyshevLobattoIntegrate,IdentityMatrix[n]].DiagonalMatrix[ConstantArray[1.,n]MapFromIntervalD[d,Points[UnitInterval,n]]/.ComplexInfinity\[Rule]0.];
IntegrateMatrix[f_]:=IntegrateMatrix[f//Domain,f//Length];

ReduceDimensionIntegrateMatrix[d_,n_Integer]:=ReduceDimensionMatrix[d,n+1].IntegrateMatrix[d,n];
ReduceDimensionIntegrateMatrix[f_]:=ReduceDimensionIntegrateMatrix[f//Domain,f//Length];*)
AddBasisElement[m_,p_]:=Module[{Dm},
Dm=m;
Dm[[1,All]]=BasisVector[Length[m]][p];
Dm];
AddBasisElement[m_,p_,j_]:=Module[{Dm},
Dm=m;
Dm[[j,All]]=BasisVector[Length[m]][p];
Dm];
Zoom[graph_Graphics]:=With[{gr=First[graph],opt=DeleteCases[Options[graph],PlotRange->_],plr=PlotRange/.Options[graph,PlotRange],rectangle={Dashing[Small],Line[{#1,{First[#2],Last[#1]},#2,{First[#1],Last[#2]},#1}]}&},DynamicModule[{dragging=False,first,second,range=plr},Panel@EventHandler[Dynamic@Graphics[If[dragging,{gr,rectangle[first,second]},gr],PlotRange->range,Sequence@@opt],{{"MouseDown",1}:>(first=MousePosition["Graphics"]),{"MouseDragged",1}:>(dragging=True;
second=MousePosition["Graphics"]),{"MouseUp",1}:>If[dragging,dragging=False;
range=Transpose@{first,second},range=plr]}]]];
Zipper[X_List,Y_List] := Table[{X[[i]],Y[[i]]},{i,1,Length[X]}];
Zipper[X_,Y_List,Z_List]:=Table[{X,Y[[i]],Z[[i]]},{i,1,Length[Y]}];
Zipper[X_List,Y_List,Z_List]:=Table[{X[[i]],Y[[i]],Z[[i]]},{i,1,Length[X]}];
Linspace[a_,b_,n_]:=Table[i,{i,0,n-1}]/(n-1)(b-a)+a;
Linspace[X_]:=Table[i,{i,0,X[[3]]-1}]/(X[[3]]-1)(X[[2]]-X[[1]])+X[[1]];
mComplexPlot3D[F_,x_,y_]:=Module[{X,Y,RE,IM,ABS,i,out},
X= Linspace[x];
Y = Linspace[y];
RE ={};
IM={};
ABS={};
For[i=1,i<=Length[X],i++,
out=F[I Y + X[[i]]];
RE = Join[RE,Zipper[X[[i]],Y,out//Re]];
IM = Join[IM,Zipper[X[[i]],Y,out//Im]];
ABS = Join[ABS,Zipper[X[[i]],Y,out//Abs]]];
{ListPlot3D[RE],ListPlot3D[IM],ListPlot3D[ABS]}];
RHPDerivative[j_,F_]:=Table[F[[i]]//ToUnitInterval//Derivative[j],{i,1,Length[F]}];
RHPNorm[S_]:=Module[{a},
a =-(AddIdentityMatrix[-S]);
 Table[Max[Abs[a[[i]]]],{i,1,Length[S]}]];


RHPNormCoordinate[S_]:=Table[{i,(S//RHPNorm//Chop)[[i]]},{i,1,Length[S]}];
FindZerosVect[A_]:=Module[{out,ij},
out={};
For[ij=1,ij<=Length[A],ij++,
If[A[[ij,2]]==0, out=Join[out,{A[[ij,1]]}];];
];
out
];
RemoveEntries[S_,index_]:=Module[{a,ij},
a = S;
For[ij=Length[index],ij>=1,ij--,
a = Delete[a,index[[ij]]];
];
a];
Trim[S_]:=RemoveEntries[S,FindZerosVect[RHPNormCoordinate[S]]];


cc[z_]:=Conjugate[z];
SignChange[x_,y_]:=If[Sign[x]*Sign[y]==-1,True,False];

(*Truncation for lines*)
TruncateMatrix[tol_][{F_,Domain_,n_}]:=Module[{f},
f[x_]:=Norm[F[x]-IdentityMatrix[2]];
Truncate[tol][{f,Domain,n}]
];
Truncate[tol_][{F_,Domain_,n_}]:=Module[{f1,vals,x,dx,i,Change},
dx = .025/Abs[MapFromIntervalD[Domain,1]];(*determines the increment, not sure why the derivative is involved*)
f1 = Fun[0&,Domain,n];
vals=Table[{Abs[F[MapFromInterval[f1,x]]]-tol,MapFromInterval[f1,x]},{x,-1,1,dx}];
(*vals contains a vector of values of (abs(F)-tol) at the image of uniform distributed points under conformal mapping*)
Change={};
If[Abs[F[MapFromInterval[f1,-1]]]-tol>0,   (*if the value at the left end is greater than tol*)
Change={{MapFromInterval[f1,-1],1}};
];
(*Print["Initialization: ",Change,"  first value:  ", Abs[F[MapFromInterval[f1,-1]]]-tol];*)
(*Guaranteed to work only for evelope (positive)*)
For[i=1,i<=Length[vals]-1,i++,
If[SignChange[vals[[i,1]],vals[[i+1,1]]],Change=Join[Change,{{(vals[[i,2]]+vals[[i+1,2]])/2,Sign[vals[[i+1,1]]]}}];
];
];
If[Change !={}&&Change[[-1]][[2]]==1, (*-1 index is for the last element*)
Change=Join[Change,{{MapFromInterval[f1,1],-1}}];
];
(*Print[{Domain,Change//CreateDomains}];*)
(*Print[{Domain//DomainPlot,Fun[vals[[All,1]],Domain],Change//CreateDomains}];*)
Change//CreateDomains
];
CreateDomains[V_]:=Module[{i,out},
out = {};
For[i=1,i<=Length[V],i=i,
If[V[[i,2]]==1,
out =Join[out,{Line[{V[[i,1]],V[[i+1,1]]}]}];
i = i+2;
,
i = i+1;(*if not*)
];
];
out
];
(*Arcs only*)
TruncateArcs[tol_][{F_,Domain_,n_}]:=Module[{f1,vals,x,nn,i,Change,a,r,\[Theta]s,\[Theta]e},
a=Domain[[1]];
r=Domain[[2]];
{\[Theta]s,\[Theta]e}=Domain[[-1]];
nn = Max[20,Ceiling[r/.01]];
f1 = Fun[0&,Domain,n];
x =\[Theta]s+ Table[i/nn,{i,0,nn}](\[Theta]e-\[Theta]s)//N;
vals=Transpose[{Abs[F/@(a + r Exp[I x])]-tol,x}];


Change={};
If[Abs[F[MapFromInterval[f1,-1]]]-tol>0,
Change={{\[Theta]s,1}};
];
(*Print["Initialization: ",Change,"  first value:  ", Abs[F[MapFromInterval[f1,-1]]]-tol];*)
(*Guaranteed to work only for evelope (positive)*)
For[i=1,i<=Length[vals]-1,i++,
If[SignChange[vals[[i,1]],vals[[i+1,1]]],Change=Join[Change,{{(vals[[i,2]]+vals[[i+1,2]])/2,Sign[vals[[i+1,1]]]}}];
];
];
If[Change !={}&&Change[[-1]][[2]]==1,
Change=Join[Change,{{\[Theta]e,-1}}];
];
(*Print[{Domain,Change//CreateDomains}];*)
(*Print[{Domain//DomainPlot,Fun[vals[[All,1]],Domain],Change//CreateDomains}];*)
Change//CreateArcs[a,r]
];
CreateArcs[a_,r_][V_]:=Module[{i,out},
out = {};
For[i=1,i<=Length[V],i=i,
If[V[[i,2]]==1,
out =Join[out,{Arc[a,r,{V[[i,1]],V[[i+1,1]]}]}];
i = i+2;,
i = i+1;
];
];
out];

(* Modified to handle both arcs and lines*)
TruncateArcsLines[tol_][{F_,Domain_,n_}]:=Module[{f1,vals,x,dx,i,Change,arc},
arc=(ListQ[Domain[[-1]]] && !ListQ[Domain[[1]]]);(*True if it's an arc*)
If[arc,TruncateArcs[tol][{F,Domain,n}],Truncate[tol][{F,Domain,n}]]
];
(*for arcs only*)
TruncateMatrixArcsLines[tol_][{F_,Domain_,n_}]:=Module[{f},
f[x_]:=Norm[F[x]-IdentityMatrix[2]];
TruncateArcsLines[tol][{f,Domain,n}]
];

Adapt[f_,tol_][F_]:= Module[{out,save,i,j},
(*f is a matrix with each collum being a section of the contour*)
(*f[[All,i]] extracts the ith collum *)
out = Table[f[[All,i]]//TruncateMatrix[tol],{i,1,f//Transpose//Length}];
(*Length returns the row number, that's why we need a transpose*)
(*out is a matrix where each row represents a partition of one part of the domain*)
save={{}};
For[i=1,i<=Length[out],i++,(*out contains straight line segemnts of the domain that have values larger than the tol, this loop is running over the number of parts of domain*)
For[j=1,j<=Length[out[[i]]],j++, (*this loop is running over the number of partitions after truncating the ith part of the domain*)
save = Join[save,{{F[[1,i]],out[[i,j]],F[[3,i]]}}//Transpose,2]
(*join 1 means stacking matrix vertically 
  join 2 means stacking matrix horizontally*)
];
];
save
];

AdaptArcsLines[f_,tol_][F_]:= Module[{out,save,i,j},
out = Table[f[[All,i]]//TruncateMatrixArcsLines[tol],{i,1,f//Transpose//Length}];
save={{}};
For[i=1,i<=Length[out],i++,
For[j=1,j<=Length[out[[i]]],j++,
save = Join[save,{{F[[1,i]],out[[i,j]],F[[3,i]]}}//Transpose,2]
];
];
save
];
LineConjugate[L_List]:=Table[Line[L[[i,1]]//Conjugate],{i,1,Length[L]}];
LineReverse[L_List]:=Table[Line[L[[i,1]]//Reverse],{i,1,Length[L]}];
mRHWellPosed[GG_,Gg_]:=Dot@@(If[LeftEndpoint[#]~NEqual~(Gg),
First[#],
Inverse[Last[#]]]&/@
SelectWithPoint[GG,Gg])//Chop//MatrixForm;
mRHWellPosed[GG_]:=Zipper[mRHWellPosed[GG,#]&/@Endpoints[GG],Endpoints[GG]]//MatrixForm;


MultFun[L_,2]:=L[[1]][#].L[[2]][#]&;
MultFun[L_,3]:=L[[1]][#].L[[2]][#].L[[3]][#]&;
MultFun[L_,4]:=L[[1]][#].L[[2]][#].L[[3]][#].L[[4]][#]&;
MultFun[L_,5]:=L[[1]][#].L[[2]][#].L[[3]][#].L[[4]][#].L[[5]][#]&;
MultFun[L_,6]:=L[[1]][#].L[[2]][#].L[[3]][#].L[[4]][#].L[[5]][#].L[[6]][#]&;
MultFun[L_,7]:=L[[1]][#].L[[2]][#].L[[3]][#].L[[4]][#].L[[5]][#].L[[6]][#].L[[7]][#]&;
MultFun[L_,8]:=L[[1]][#].L[[2]][#].L[[3]][#].L[[4]][#].L[[5]][#].L[[6]][#].L[[7]][#].L[[8]][#]&;
MultFun[L_,9]:=L[[1]][#].L[[2]][#].L[[3]][#].L[[4]][#].L[[5]][#].L[[6]][#].L[[7]][#].L[[8]][#].L[[9]][#]&;
MultFun[L_,10]:=L[[1]][#].L[[2]][#].L[[3]][#].L[[4]][#].L[[5]][#].L[[6]][#].L[[7]][#].L[[8]][#].L[[9]][#].L[[10]][#]&;
MultFun[L_,11]:=L[[1]][#].L[[2]][#].L[[3]][#].L[[4]][#].L[[5]][#].L[[6]][#].L[[7]][#].L[[8]][#].L[[9]][#].L[[10]][#].L[[11]][#]&;
MultFun[L_]:=MultFun[L,Length[L]];
(*Could have done this recursively*)
InvFun[F_][k_]:=Inverse[F[k]];
MakeListFun[{{}}]={};
MakeListFun[{Jumps_,Domains_,NumPts_}]:=Table[Fun[Jumps[[i]],Domains[[i]],NumPts[[i]]],{i,1,Length[Jumps]}]//Flatten;
MakeListLFun[{Jumps_,Domains_,NumPts_}]:=Table[LFun[Jumps[[i]],Domains[[i]],NumPts[[i]]],{i,1,Length[Jumps]}]//Flatten;
ConjugateJumps[Jumps_,F_]:= Table[MultFun[{InvFun[F],Jumps[[i]],F}],{i,1,Length[Jumps]}];
ConjugateList[L_,F_]:={ConjugateJumps[L[[1]],F],L[[2]],L[[3]]};
(*only L1 is conjugated because L1 is the function while L2 is the domain and L3 is the number of nodes*)
RightMultiplyJumps[Jumps_,F_]:= Table[MultFun[{Jumps[[i]],F}],{i,1,Length[Jumps]}];
LeftMultiplyJumps[Jumps_,F_]:= Table[MultFun[{F,Jumps[[i]]}],{i,1,Length[Jumps]}];
RightMultiplyList[L_,F_]:={RightMultiplyJumps[L[[1]],F],L[[2]],L[[3]]};
LeftMultiplyList[L_,F_]:={LeftMultiplyJumps[L[[1]],F],L[[2]],L[[3]]};
MakeZeroFun[domains_]:={Table[0&,{i,Length[domains]}],domains,Table[2,{i,Length[domains]}]}//MakeListFun;


End[];
EndPackage[];
