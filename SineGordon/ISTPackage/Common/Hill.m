(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



BeginPackage[$Library];


mFFT::usage="my DFT";
InvmFFT::usage="Inverse of my DFT"
FFTShift::usage="Change periodicity over [-a,a] to [0,2a]";
Eye::usage="Eye[n,k] generates n by n matrix with 1 in the k-off diagonal entries, i.e. Eye[n,0] is the n by n identity matrix"
HillMat::usage="A single Hill matrix"
Hill::usage="General block Hill matrix, if the (differential) eigenvalue problem on [-L,L] has the form

f00 u_0 + f10 u_0' + f01 u_1 + f11 u_1' = lambda u0
g00 u_0 + g10 u_0' + g01 u_1 + g11 u_1' = lambda u1

Define
F = { { {f00,f10}, {f01,f11} }, { {g00,g10}, {g01,g11} } }
Then to obtain the Hill matrix call
Hill[mu,L,N,P,F];

or
c = FourierCoef[L,N,F];
Hill[mu,L,N,P,F,C];
which avoids recomputing c for each mu (Floquet parameter)."

Hill2::usage="For solving the quadratic eigenvalue problem like in sine-Gordon 
General block Hill matrix, if the (differential) eigenvalue problem on [-L,L] has the form

f00 u_0 + f10 u_0' + f01 u_1 + f11 u_1' + f02 u_2 + f12 u_2' + f03 u_3 + f13 u_3' = lambda u0

g00 u_0 + g10 u_0' + g01 u_1 + g11 u_1' + g02 u_2 + g12 u_2' + g03 u_3 + g13 u_3' = lambda u1

h00 u_0 + h10 u_0' + h01 u_1 + h11 u_1' + h02 u_2 + h12 u_2' + h03 u_3 + h13 u_3' = lambda u2

i00 u_0 + i10 u_0' + i01 u_1 + i11 u_1' + i02 u_2 + i12 u_2' + i03 u_3 + i13 u_3' = lambda u3

Define
F = { { {f00,f10}, {f01,f11}, {f02,f12}, {f03,f13} },
      { {g00,g10}, {g01,g11}, {g02,g12}, {g03,g13} },
	  { {h00,h10}, {h01,h11}, {h02,h12}, {h03,h13} },
	  { {i00,i10}, {i01,i11}, {i02,i12}, {i03,i13} }
	}"
FourierCoef::usage="returns first 2N+1 fourier coefficients"
InvHillCoef::usage="Returns function value at 2N+1 points"
ShiftCenter::usage=""


Begin["Private`"];
mFFT[F_]:=Fourier[F,FourierParameters->{-1,-1}];
InvmFFT[F_]:=InverseFourier[F,FourierParameters->{-1,1}];
FFTShift[V_]:=Module[{n},
n = Length[V]/2;
Join[V[[n+1;;]],V[[1;;n]]]];
FourierCoef[L_,N_,F_]:=Module[{C,p,x,y},
p = 2;
(*Print[F];*)
While[p < N, p = 2*p];
x = Table[n, {n, 0.0, 2.0*p - 1}]*L/(p) - L;
y = F[x]/.Underflow[]->0;
y = mFFT[FFTShift[y]];
C = ConstantArray[0, 2*N + 1];
 C[[1 ;; N + 1]] = y[[1 ;; N + 1]];
      C[[-N ;; -1]] = y[[-N ;; -1]];
       C];
InvHillCoef[F_]:=ShiftCenter[InvmFFT[ShiftCenter[Join[F,{0.}]]],1];
ShiftCenter[F_]:=Module[{n},
If[Mod[Length[F],2]==1,n = (Length[F]-1)/2;,n = Length[F]/2-1];Join[F[[n+1;;]],F[[;;n]]]
];
ShiftCenter[F_,offset_]:=Module[{n},
If[Mod[Length[F],2]==1,n = (Length[F]-1)/2;,n = Length[F]/2-1];
Join[F[[n+1+offset;;]],F[[;;n+offset]]]
];
FourierCoef[L_,N_,F_List]:=Module[{C,p,x,y,i,j,k},
C = F;
For[k=1,k<=Length[F],k++,
For[i=1,i<= Length[F[[k]]],i++,
For[j =1,j <= Length[F[[k,i]]],j++,
(*Print["Computing coef of ",k,i,j];*)
C[[k,i,j]]=FourierCoef[L,N,F[[k,i,j]]];
];
];
];
C];
Eye[n_,k_]:=DiagonalMatrix[Table[1,{i,1,n}],k,n];
HillMat[C_,k_,mu_,L_,N_,P_]:=Module[{a,n,B,c,M,m,s},
M = ConstantArray[0,{2*N+1,2*N+1}];
For[n=-(2*N+1)+1,n<=2*N+1,n++,
If [n>=1,
If[Mod[n-1,P] ==0,
M = M+ C[[(n-1)/P+1]]*Eye[2*N+1,-n+1];
];,
If[Mod[n,P]==0 && n < 0,
M = M+ C[[(n)/P]]*Eye[2*N+1,-n];
]
]
];
(*this constructed all the entries with only the fhat not the imag power part*)
B = ConstantArray[0,{2*N+1,2*N+1}];
(*B = Transpose[M];*)
B=M;
For[s=1,s<=2*N+1,s++,
If[k > 0,
B[[1;;,s]]=(I*(mu+Pi*(s-1-N)/(P*L)))^k*B[[1;;,s]];
]
];
B];
Hill[mu_,L_,N_,P_,F_List]:=Module[{A,C,i,j,k,row1,sum},
C=FourierCoef[L,N,F];
(*Print["Coef done"];*)
A={};
For[k=1,k<=Length[F],k++,
row1={{}};
For[i=1,i<= Length[F[[k]]],i++,
sum=Sum[HillMat[C[[k,i,j]],j-1,mu,L,N,P],{j,1,Length[F[[k,i]]]}];
row1=Join[row1,sum,2];
];
A = Join[A,row1]
];
A];
Hill[mu_,L_,N_,P_,F_,C_List]:=Module[{A,i,j,k,row1,sum},
A={};
For[k=1,k<=Length[C],k++,
row1={{}};
For[i=1,i<= Length[C[[k]]],i++,
sum=Sum[HillMat[C[[k,i,j]],j-1,mu,L,N,P],{j,1,Length[C[[k,i]]]}];
row1=Join[row1,sum,2];
];
A = Join[A,row1]
];
A];


End[];
EndPackage[];
