(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



Needs["RiemannHilbert`"];
HillNLS::usage="HillNLS[q,n] gives the eigenvalues of the modified Zakharov-Shabat scattering (including continuous spectrum) problem with n Fourier modes using Hill's method.";
LocatePolesNLS::usage="LocatePoles[q,n] gives the true eigenvalues of the modified Zakharov-Shabat scattering problem.";
NLS::usage="NLS[i][x,t] = {out,\[CapitalPhi],rhp1,rhp2,timestring} where out is the solution of NLS, \[CapitalPhi] is the solution of the Riemann-Hilbert problem, rhp1 and rhp2 are the Riemann-Hilbert problems and timestring is the string of computation times.  This is done using the deformation in Region i.";
NLSAuto::usage="NLSAuto[x,t] returns the solution of the NLS equation with deformation selected automagically.  Many things must be initialized.  Sample code:

	q[x_]:=.1 Exp[-x^2+I x];\[IndentingNewLine]Defocusing[];
	H=ScatteringMatrixFiniteNLS[q,50,6];\[IndentingNewLine]aa//Clear;bb//Clear;\[IndentingNewLine]aa[k_]:=aa[k]=H[k][[1,1]];\[IndentingNewLine]bb[k_]:=bb[k]=H[k][[2,1]];
	SetParams[.6,.1,10.^(-9),15,30];\[IndentingNewLine]h[k_]:=3/(1+Abs[k/2+1/3.2]^8);\[IndentingNewLine]Setrsamp[h];\[IndentingNewLine]Settimeflag[False];\[IndentingNewLine]\[Nu]=Getnu[];\[IndentingNewLine]\[Rho][k_]:=bb[k]/aa[k];
	up=I(\[Nu]+.0001);m=40;el=8;\[IndentingNewLine]f={Fun[\[Rho],Line[{-el,0}-up],m],Fun[\[Rho],Line[{0,el}-up],m],Fun[\[Rho],Line[{el,0}+up],m],Fun[\[Rho],Line[{0,-el}+up],m]};

	up=I(\[Nu]+.0001);m=40;el=8;\[IndentingNewLine]f={Fun[\[Rho],Line[{-el,0}-up],m],Fun[\[Rho],Line[{0,el}-up],m],Fun[\[Rho],Line[{el,0}+up],m],Fun[\[Rho],Line[{0,-el}+up],m]};
SetScatteringData[aa,bb,m\[Rho],LocatePoles[q,40]]"
Focusing::usage="Focusing[], switch to focusing NLS";
Defocusing::usage="Defocusing[], switch to focusing NLS";
SetScatteringData::usage="SetScatteringData[a,b,\[Rho],poles] or SetScatteringData[a,b,\[Rho],poles,normingConstants] sets the scattering data for the NLS equation";
SetParams::usage="SetParams[\[Nu],rad,globalTol,smallN,bigN] sets the parameters for the rest of the code:
	\[Nu]: half of width of strip of analyticity
	rad: radius of soliton contours
	globalTol: contour truncation tolerance
	smallN: small number of collocation points
	bigN: big number of collocation points";
GetScatteringData::usage="GetScatteringData[] = {\[Rho],poles,normingConstants}";
ScatteringMatrixFiniteNLS::usage="ScatteringMatrixFiniteNLS[q,n,L] returns a function f[w] that produces an approximation of the scattering matrix at w. The parameter n indicates the number of collocation points and L sets the problem on [-L,L]
Sample code:
	q[x_]:=.1 Exp[-x^2+I x];\[IndentingNewLine]Defocusing[];
	H=ScatteringMatrixFiniteNLS[q,50,6];\[IndentingNewLine]aa//Clear;bb//Clear;\[IndentingNewLine]aa[k_]:=aa[k]=H[k][[1,1]];\[IndentingNewLine]bb[k_]:=bb[k]=H[k][[2,1]];
";
Getnu::usage="Getnu[] returns \[Nu]";
Setrsamp::usage="Setrsamp[h] sets a function that should be chosen so that that |\[Rho]| < h";
timestring::usage="A string updated by NLS[i][x,t]
(x,t) 1) Construct: --time to construct rhp1-- 1) Solve: --time to solve rhp1-- 2) Construct: --time to construct rhp2-- 2) Solve: --time to solve rhp2--";
Settimeflag::usage="Settimeflag[bool] bool = True forces timestring to be printed each time NLS[i][x,t] is called";
startift;
domainOutput;
domainOutput2;
ift;
\[CapitalPhi]t;
dom;
Jadapt;J;Jsamp;
DDn;Ln;Un;Mn;Pn;
Grhp1;Grhp0;G;
Begin["Private`"];


Focusing[]:=Module[{},\[Lambda]=1];
Defocusing[]:=Module[{},\[Lambda]=-1];
SetScatteringData[aa_,bb_,rr_,ma_,mc_]:=Module[{},
r[k_]:=rr[k];
a=ma;
\[Tau][k_]:=1+\[Lambda] r[k]cc[r[cc[k]]];
\[Tau][_?InfinityQ]:=1;
\[Tau][k_List]:=\[Tau]/@k;
dom=Truncate[globalTol][{Log[1+h[#]^2]&,Line[{-el,el}],100}][[1]];
c=mc;
];
SetScatteringData[aa_,bb_,rr_,ma_]:=Module[{},
r[k_]:=rr[k];
a=ma;
\[Tau][k_]:=1+\[Lambda] r[k]cc[r[cc[k]]];
\[Tau][_?InfinityQ]:=1;
\[Tau][k_List]:=\[Tau]/@k;
dom=Truncate[globalTol][{Log[1+rsamp[#]^2]&,Line[{-el,el}],100}][[1]];
(*dom=Truncate[globalTol][{Log[1+h[#]^2]&,Line[{-el,el}],100}][[1]];  Not clear what is this.*)
(*dom=Truncate[globalTol][{h[#]&,Line[{-el,el}],100}][[1]]; something that I think should be*)
f1 = Fun[aa[#]-1&,Line[{-\[Infinity],0}],4*bigN];
f2 = Fun[aa[#]-1&,Line[{0,\[Infinity]}],4*bigN];
df1=f1';
df2=f2';
(*this f1 is not defined so there may be problems in focusing NLS when it is actually used*)
da[k_]:=Cauchy[df1,k]+Cauchy[df2,k];
(*we can use the Cauchy transform to get the extension provided that there's a band of analyticity of df1 containing the discrete spectrum and the real line*)
c={};
For[i=1,i<=Length[ma],i++,
c=Join[c,{Quiet[bb[ma[[i]]]]/da[ma[[i]]]}];(*compute norming constants*)
];
Print[c]
];
SetParams[nu_,rad1_,tol_,sN_,bN_]:=Module[{},
\[Nu]=nu; (*parameter for width of strip of analyticity*)
rad=rad1;
globalTol=tol;
smallN=sN;
bigN=bN;
];
GetScatteringData[]:=Module[{},{r,a,c}];
Getnu[]:=\[Nu];
Setrsamp[h_]:=Module[{},rsamp=h];
Settimeflag[h_]:=Module[{},timeflag=h];
SetN[x_]:=Module[{},bigN=x[[1]];smallN=x[[2]];];
expconst=1;
el=100;
bigN=20;
smallN=10;


\[Theta][x_,t_][z_]:=2 I (2 t z^2+x z);
(*cc short for complex conjugate*)
rb[k_]:=\[Lambda] cc[r[cc[k]]];
rbsamp[k_]:=\[Lambda] cc[rsamp[cc[k]]];
\[Tau]samp[k_]:=1+\[Lambda] rsamp[k]cc[rsamp[cc[k]]];
(*This is r over tau*)
Ln[x_,t_][k_]:=({
 {1, 0},
 {r[k]/\[Tau][k] Exp[\[Theta][x,t][k]], 1}
});
(*all the ones using samp are using the envolope function*)
Lnsamp[x_,t_][k_]:=({
 {1, 0},
 {rsamp[k]/\[Tau]samp[k] Exp[\[Theta][x,t][k]], 1}
});
(*in means inverse*)
Linn[x_,t_][k_]:=({
 {1, 0},
 {-(r[k]/\[Tau][k])Exp[\[Theta][x,t][k]], 1}
});
Linnsamp[x_,t_][k_]:=({
 {1, 0},
 {-(rsamp[k]/\[Tau]samp[k])Exp[\[Theta][x,t][k]], 1}
});


Un[x_,t_][k_]:=({
 {1, rb[k]/\[Tau][k] Exp[-\[Theta][x,t][k]]},
 {0, 1}
});
Unsamp[x_,t_][k_]:=({
 {1, rbsamp[k]/\[Tau]samp[k] Exp[-\[Theta][x,t][k]]},
 {0, 1}
});

DDn[k_]:=({
 {\[Tau][k], 0},
 {0, 1/\[Tau][k]}
});

DDnsamp[k_]:=({
 {\[Tau]samp[k], 0},
 {0, 1/\[Tau]samp[k]}
});

G[x_,t_][z_]:=({
 {1+r[z]rb[z], rb[z]Exp[-2 I (2 t z^2+x z)]},
 {r[z] Exp[2 I (2 t z^2+ x z)], 1}
});
G[_,_][_?InfinityQ]:=({
 {1., 0},
 {0, 1.}
});
Gsamp[x_,t_][z_]:=({
 {1+rsamp[z]rbsamp[z], rbsamp[z]Exp[-2 I (2 t z^2+x z)]},
 {rsamp[z] Exp[2 I (2 t z^2+ x z)], 1}
});
Gsamp[_,_][_?InfinityQ]:=({
 {1., 0},
 {0, 1.}
});
Mn[x_,t_][k_]:=({
 {1, rb[k] Exp[-\[Theta][x,t][k]]},
 {0, 1}
});
Mnsamp[x_,t_][k_]:=({
 {1, rbsamp[k] Exp[-\[Theta][x,t][k]]},
 {0, 1}
});
Pn[x_,t_][k_]:=({
 {1, 0},
 {r[k] Exp[\[Theta][x,t][k]], 1}
});
Pnsamp[x_,t_][k_]:=({
 {1, 0},
 {rsamp[k] Exp[\[Theta][x,t][k]], 1}
});


qn[x_,t_][k_]:=Module[{out,i},
out = 1;
For[i=1,i<=Length[a],i++,
If[Abs[c[[i]]]Exp[Re[\[Theta][x,t][a[[i]]]]]>expconst,
out = out*(k-a[[i]])/(k-Conjugate[a[[i]]]);
];
];
out];
Qn[x_,t_][k_]:=({
 {qn[x,t][k], 0},
 {0, 1/qn[x,t][k]}
});
Qn[x_,t_][_?InfinityQ]:=({
 {1., 0},
 {0, 1.}
});


\[CapitalPhi]s[x_,t_][z_]:=\[CapitalPhi][z/Sqrt[t]-x/(4 t)];
\[CapitalPhi]ins[x_,t_][z_]:=\[CapitalPhi]in[z/Sqrt[t]-x/(4 t)]
rs[x_,t_][z_]:=r[z/Sqrt[t]-x/(4 t)];
\[Tau]s[x_,t_][z_]:=\[Tau][z/Sqrt[t]-x/(4 t)];
rsb[x_,t_][z_]:=rb[z/Sqrt[t]-x/(4 t)];

\[CapitalPhi]ssamp[x_,t_][z_]:=\[CapitalPhi]samp[z/Sqrt[t]-x/(4 t)];
\[CapitalPhi]inssamp[x_,t_][z_]:=\[CapitalPhi]insamp[z/Sqrt[t]-x/(4 t)]
rssamp[x_,t_][z_]:=rsamp[z/Sqrt[t]-x/(4 t)];
\[Tau]ssamp[x_,t_][z_]:=\[Tau]samp[z/Sqrt[t]-x/(4 t)];
rsbsamp[x_,t_][z_]:=rbsamp[z/Sqrt[t]-x/(4 t)];
\[Theta]s[x_,t_][z_]:=-(I x^2)/(4 t)+4 I z^2

L[x_,t_][k_]:=({
 {1, 0},
 {rs[x,t][k]/\[Tau]s[x,t][k] Exp[\[Theta]s[x,t][k]], 1}
});
Lsamp[x_,t_][k_]:=({
 {1, 0},
 {rssamp[x,t][k]/\[Tau]ssamp[x,t][k] Exp[\[Theta]s[x,t][k]], 1}
});

Lin[x_,t_][k_]:=({
 {1, 0},
 {-rs[x,t][k]/\[Tau]s[x,t][k] Exp[\[Theta]s[x,t][k]], 1}
});
Linsamp[x_,t_][k_]:=({
 {1, 0},
 {-rssamp[x,t][k]/\[Tau]ssamp[x,t][k] Exp[\[Theta]s[x,t][k]], 1}
});

U[x_,t_][k_]:=({
 {1, rsb[x,t][k]/\[Tau]s[x,t][k] Exp[-\[Theta]s[x,t][k]]},
 {0, 1}
});
Usamp[x_,t_][k_]:=({
 {1, rsbsamp[x,t][k]/\[Tau]ssamp[x,t][k] Exp[-\[Theta]s[x,t][k]]},
 {0, 1}
});

Uin[x_,t_][k_]:=({
 {1, -rsb[x,t][k]/\[Tau]s[x,t][k] Exp[-\[Theta]s[x,t][k]]},
 {0, 1}
});
Uinsamp[x_,t_][k_]:=({
 {1, -rsbsamp[x,t][k]/\[Tau]ssamp[x,t][k] Exp[-\[Theta]s[x,t][k]]},
 {0, 1}
});

M[x_,t_][k_]:=({
 {1, rsb[x,t][k] Exp[-\[Theta]s[x,t][k]]},
 {0, 1}
});
Msamp[x_,t_][k_]:=({
 {1, rsbsamp[x,t][k] Exp[-\[Theta]s[x,t][k]]},
 {0, 1}
});

Mi[x_,t_][k_]:=({
 {1, -rsb[x,t][k] Exp[-\[Theta]s[x,t][k]]},
 {0, 1}
});
Misamp[x_,t_][k_]:=({
 {1, -rsbsamp[x,t][k] Exp[-\[Theta]s[x,t][k]]},
 {0, 1}
});

P[x_,t_][k_]:=({
 {1, 0},
 {rs[x,t][k] Exp[\[Theta]s[x,t][k]], 1}
});
Psamp[x_,t_][k_]:=({
 {1, 0},
 {rssamp[x,t][k] Exp[\[Theta]s[x,t][k]], 1}
});

Pin[x_,t_][k_]:=({
 {1, 0},
 {-rs[x,t][k] Exp[\[Theta]s[x,t][k]], 1}
});
Pinsamp[x_,t_][k_]:=({
 {1, 0},
 {-rssamp[x,t][k] Exp[\[Theta]s[x,t][k]], 1}
});


DD[x_,t_][k_]:=({
 {\[Tau]s[x,t][k], 0},
 {0, 1/\[Tau]s[x,t][k]}
});
DDsamp[x_,t_][k_]:=({
 {\[Tau]ssamp[x,t][k], 0},
 {0, 1/\[Tau]ssamp[x,t][k]}
});

Q[x_,t_][z_]:=({
 {qn[x,t][z/Sqrt[t]-x/(4 t)], 0},
 {0, 1/qn[x,t][z/Sqrt[t]-x/(4 t)]}
});



CME[x_]:=Chop[x,$MachineEpsilon];
ScatteringMatrixFiniteNLS[q_,n_,el_]:=Module[{qf,qfb,Dm,Dmb,IIm,IImb,P,Pb,id,Q,R,Qb,Rb,DM,DMb,q\[Sigma]1,q\[Sigma]1b,J\[Sigma]3,J\[Sigma]31,J\[Sigma]3b,J\[Sigma]31b,rhs,A,Ab},
 qf=Fun[q,Line[{-el,0}],n];
qfb=Fun[q,Line[{0,el}],n];
Print[{qf//Values//First//Abs,qf//DCTPlot}];
Dm=DerivativeMatrix[qf];
Dmb=DerivativeMatrix[qfb];
IIm=ReduceDimensionIntegrateMatrix[qf];
IImb=(ReduceDimensionIntegrateMatrix[(qfb//ReverseOrientation)]//Transpose//Reverse//Transpose//Reverse);
id=IdentityMatrix[n];
Q = DiagonalMatrix[qf//Values];
R= -\[Lambda] DiagonalMatrix[qf//Conjugate//Values];
Qb = DiagonalMatrix[qfb//Values];
Rb = -\[Lambda] DiagonalMatrix[qfb//Conjugate//Values];
A=BlockMatrix[{{id,-IIm.Q},{-IIm.R,id}}];
Ab=BlockMatrix[{{id,-IImb.Qb},{-IImb.Rb,id}}];
J\[Sigma]3=BlockMatrix[{{0*id,0},{0,-2I IIm}}];
J\[Sigma]31=BlockMatrix[{{2I IIm,0},{0,0*id}}];
J\[Sigma]3b=BlockMatrix[{{0*id,0},{0,-2I IImb}}];
J\[Sigma]31b=BlockMatrix[{{2I IImb,0},{0,0*id}}];
ScatteringMatrixFiniteNLS[qf,qfb,A,Ab,J\[Sigma]3,J\[Sigma]31,J\[Sigma]3b,J\[Sigma]31b,IIm,IImb]];
ScatteringMatrixFiniteNLS[qf_,qfb_,A_,Ab_,J\[Sigma]3_,J\[Sigma]31_,J\[Sigma]3b_,J\[Sigma]31b_,IIm_,IImb_][w_]:=Module[{ans0,ans1,rhs,lhs,n,s1,s2,qb,q,r,rb},
q = qf//Values;
qb = qfb//Values;
r = -\[Lambda] q//Conjugate;
rb= -\[Lambda] qb//Conjugate;
n = q//Length;
lhs=A+ w*J\[Sigma]3;
rhs = Join[ConstantArray[0.,n],IIm.r];
ans0 = LinearSolve[lhs//CME,rhs//CME];
lhs=A+w*J\[Sigma]31;
rhs=Join[IIm.q,ConstantArray[0.,n]];
ans1 = LinearSolve[lhs//CME,rhs//CME];
s1={{ans0[[n]]+1,-ans1[[n]]},{ans0[[2n]],-ans1[[2n]]-1}};
lhs=Ab+ w*J\[Sigma]3b;
Off[LinearSolve::luc];
rhs = Join[ConstantArray[0.,n],IImb.rb];
ans0 = LinearSolve[lhs//CME,rhs//CME];
lhs=Ab+ w*J\[Sigma]31b;
rhs = Join[IImb.qb,ConstantArray[0.,n]];
ans1 = LinearSolve[lhs//CME,rhs//CME];
On[LinearSolve::luc];
s2={{ans0[[1]]+1,ans1[[1]]},{ans0[[n+1]],ans1[[n+1]]+1}};
s1=Inverse[s2].s1
];


HillNLS[F_,n_]:=Module[{c2,c1,c0,f11,f12,zz,f02,f01,t,A,mu,L,P,fun},
Off[General::unfl];
Off[General::ovfl];
mu = .25;
L = Pi;
P =1;
f11[x_]:= 2I Cos[x/2]^2;
f12[x_]:=-2I Cos[x/2]^2;
zz[x_]:=ConstantArray[0.,Length[x]];
t[x_] := Tan[x/2];
f02[x_]:= -I F[t[x]];
f01[x_]:=-\[Lambda] I Conjugate[F[t[x]]];
fun= {{{zz,f11},{f02,zz}},{{f01,zz},{zz,f12}}};
A= Hill[mu,L,n,P,fun];
On[General::unfl];
On[General::ovfl];
Eigenvalues[Chop[A,$MachineEpsilon]]
];
LocatePolesNLS[F_,n_]:=Module[{eval,s,i,sys,vecs},
Off[General::unfl];
eval=HillNLS[F,n];
s = {};
For[i=1,i<=Length[eval],i++,
If[Im[eval[[i]]]>10^(-4)&& Abs[eval[[i]]]<30,
s=Join[s,{eval[[i]]}];
];
];
On[General::unfl];
Chop[s,$MachineEpsilon]
];


J[0][x_,t_]:={{G[x,t][#]&,G[x,t][#]&},{Line[{-el,0}],Line[{0,el}]},{bigN,bigN}};
Jsamp[0][x_,t_]:={{Gsamp[x,t][#]&,Gsamp[x,t][#]&},{Line[{-el,0}],Line[{0,el}]},{bigN,bigN}};
Jadapt[0][x_,t_]:=Adapt[Jsamp[0][x,t],globalTol][J[0][x,t]]


SmallTimeContour={Line[{-el + I \[Nu],Sqrt[2]\[Nu] Exp[I 3 Pi/4]}],Line[{Sqrt[2]\[Nu] Exp[I 3 Pi/4],0}],
Line[{-el,0}],
Line[{-el - I \[Nu],Sqrt[2]\[Nu] Exp[I 5 Pi/4]}],
Line[{Sqrt[2]\[Nu] Exp[I 5 Pi/4],0}],
Line[{0,Sqrt[2]\[Nu] Exp[I Pi/4]}],
Line[{Sqrt[2]\[Nu] Exp[I Pi/4],I \[Nu] + el}],
Line[{0,Sqrt[2]\[Nu] Exp[-I Pi/4]}],
Line[{Sqrt[2]\[Nu] Exp[-I Pi/4],-I \[Nu] + el}]};
Modk0[x_,t_]:=If[t < 10*$MachineEpsilon,-Sign[x]*50,-Sign[x]*Min[Abs[x/(4t)],50]];



J[1][x_,t_]:={{Un[x,t][#]&,Un[x,t][#]&,
DDn[#]&,Ln[x,t][#]&,Ln[x,t][#]&,Pn[x,t][#]&,Pn[x,t][#]&,Mn[x,t][#]&,Mn[x,t][#]&}, SmallTimeContour + Modk0[x,t], {bigN,smallN,bigN,bigN,smallN,smallN,bigN,smallN,bigN}};
Jsamp[1][x_,t_]:={{Unsamp[x,t][#]&,Unsamp[x,t][#]&,
DDnsamp[#]&,Lnsamp[x,t][#]&,Lnsamp[x,t][#]&,Pnsamp[x,t][#]&,Pnsamp[x,t][#]&,Mnsamp[x,t][#]&,Mnsamp[x,t][#]&}, SmallTimeContour + Modk0[x,t],{bigN,smallN,bigN,bigN,smallN,smallN,bigN,smallN,bigN}};
Jadapt[1][x_,t_]:=Adapt[Jsamp[1][x,t],globalTol][J[1][x,t]]


DDI[x_,t_][k_]:=If[Im[k] >=0,DD[x,t][k],IdentityMatrix[2]];
startift[]:=Module[{},
Clear[ift];
ift[k0_]:=ift[k0]=Fun[Log[\[Tau][#]]&,{LeftEndpoint[dom],k0}//Line,100];   
];
(*ift here is not inverse Fourier transform*)
startift[];
\[Delta]t[x_,t_][s_,k_]:=(Cauchy[s,ift[-x/(4 t)],k]//Exp);
\[Delta]t[x_,t_][k_]:=(Cauchy[ift[-x/(4 t)],k]//Exp);
\[CapitalPhi]t[x_,t_][z__]:=({
 {\[Delta]t[x,t][z], 0},
 {0, 1/\[Delta]t[x,t][z]}
});
\[CapitalPhi]tin[t__][z__]:=({
 {1/\[Delta]t[t][z], 0},
 {0, \[Delta]t[t][z]}
});
\[CapitalPhi]ts[x_,t_][z_]:=\[CapitalPhi]t[x,t][z/Sqrt[t]-x/(4 t)];
\[CapitalPhi]tins[x_,t_][z_]:=\[CapitalPhi]tin[x,t][z/Sqrt[t]-x/(4 t)];
MaxRads[x_,t_]:={Min[Sqrt[2]\[Nu] *Sqrt[t],100],Min[Sqrt[2]\[Nu] *Sqrt[t]/2,1]};
J[2][x_,t_]:=Module[{Jumps,Domains,NumPts},
Jumps={
\[CapitalPhi]ts[x,t][#].L[x,t][#].\[CapitalPhi]tins[x,t][#]&,
\[CapitalPhi]ts[x,t][#].L[x,t][#].\[CapitalPhi]tins[x,t][#]&,
\[CapitalPhi]ts[x,t][#].U[x,t][#].\[CapitalPhi]tins[x,t][#]&,
\[CapitalPhi]ts[x,t][#].U[x,t][#].\[CapitalPhi]tins[x,t][#]&,
\[CapitalPhi]ts[x,t][#].M[x,t][#].\[CapitalPhi]tins[x,t][#]&,
\[CapitalPhi]ts[x,t][#].M[x,t][#].\[CapitalPhi]tins[x,t][#]&,
\[CapitalPhi]ts[x,t][#].P[x,t][#].\[CapitalPhi]tins[x,t][#]&,
\[CapitalPhi]ts[x,t][#].P[x,t][#].\[CapitalPhi]tins[x,t][#]&,
DDI[x,t][#].\[CapitalPhi]tins[x,t][#]&,
DD[x,t][#].U[x,t][#].\[CapitalPhi]tins[x,t][#]&,
Lin[x,t][#].M[x,t][#].\[CapitalPhi]tins[x,t][#]&,
Lin[x,t][#].\[CapitalPhi]tins[x,t][#]&
};
Domains={
Line[{-el Sqrt[t] - I \[Nu] Sqrt[t],MaxRads[x,t][[1]]Exp[-3I \[Pi]/4.]}],
Line[MaxRads[x,t]Exp[-3I \[Pi]/4.]],
Line[{-el Sqrt[t] + I \[Nu] Sqrt[t],MaxRads[x,t][[1]]Exp[3I \[Pi]/4.]}],
Line[MaxRads[x,t]Exp[3I \[Pi]/4.]],
Line[Reverse[MaxRads[x,t]]Exp[-I \[Pi]/4.]],
Line[{MaxRads[x,t][[1]]Exp[-I \[Pi]/4.],el Sqrt[t] - I \[Nu] Sqrt[t]}],
Line[Reverse[MaxRads[x,t]]Exp[I \[Pi]/4.]],
Line[{MaxRads[x,t][[1]]Exp[I \[Pi]/4.],el Sqrt[t] + I \[Nu] Sqrt[t]}],
Line[{Exp[-3I \[Pi]/4],Exp[3I \[Pi]/4]}*MaxRads[x,t][[2]]],
Line[{Exp[3I \[Pi]/4],Exp[I \[Pi]/4]}*MaxRads[x,t][[2]]],
Line[{Exp[I \[Pi]/4],Exp[- I \[Pi]/4]}*MaxRads[x,t][[2]]],
Line[{Exp[-I \[Pi]/4],Exp[-3 I \[Pi]/4]}*MaxRads[x,t][[2]]]
};
NumPts=Table[smallN,{i,1,12}];
NumPts[[1]]=bigN;
NumPts[[3]]=bigN;
NumPts[[6]]=bigN;
NumPts[[8]]=bigN;
{Jumps,Domains,NumPts}
];
Jsamp[2][x_,t_]:=Module[{Jumps,Domains,NumPts},
Jumps={
Lsamp[x,t][#]&,
Lsamp[x,t][#]&,
Usamp[x,t][#]&,
Usamp[x,t][#]&,
Msamp[x,t][#]&,
Msamp[x,t][#]&,
Psamp[x,t][#]&,
Psamp[x,t][#]&,
DDsamp[x,t][#]&,
DDsamp[x,t][#].Usamp[x,t][#]&,
Linsamp[x,t][#].Msamp[x,t][#]&,
Linsamp[x,t][#]&};
Domains={
Line[{-el Sqrt[t] - I \[Nu] Sqrt[t],MaxRads[x,t][[1]]Exp[-3I \[Pi]/4.]}],
Line[MaxRads[x,t]Exp[-3I \[Pi]/4.]],
Line[{-el Sqrt[t] + I \[Nu] Sqrt[t],MaxRads[x,t][[1]]Exp[3I \[Pi]/4.]}],
Line[MaxRads[x,t]Exp[3I \[Pi]/4.]],
Line[Reverse[MaxRads[x,t]]Exp[-I \[Pi]/4.]],
Line[{MaxRads[x,t][[1]]Exp[-I \[Pi]/4.],el Sqrt[t] - I \[Nu] Sqrt[t]}],
Line[Reverse[MaxRads[x,t]]Exp[I \[Pi]/4.]],
Line[{MaxRads[x,t][[1]]Exp[I \[Pi]/4.],el Sqrt[t] + I \[Nu] Sqrt[t]}],
Line[{Exp[-3I \[Pi]/4],Exp[3I \[Pi]/4]}*MaxRads[x,t][[2]]],
Line[{Exp[3I \[Pi]/4],Exp[I \[Pi]/4]}*MaxRads[x,t][[2]]],
Line[{Exp[I \[Pi]/4],Exp[- I \[Pi]/4]}*MaxRads[x,t][[2]]],
Line[{Exp[-I \[Pi]/4],Exp[-3 I \[Pi]/4]}*MaxRads[x,t][[2]]]
};
NumPts=Table[smallN,{i,1,12}];
NumPts[[1]]=bigN;
NumPts[[3]]=bigN;
NumPts[[6]]=bigN;
NumPts[[8]]=bigN;
{Jumps,Domains,NumPts}
];
Jadapt[2][x_,t_]:=Adapt[Jsamp[2][x,t],globalTol][J[2][x,t]]


DDIn[k_]:=If[Im[k] >=0,DDn[k],IdentityMatrix[2]];
MaxRadsn[x_,t_]:={Sqrt[2]\[Nu] ,Sqrt[2]\[Nu] /(2(1+Sqrt[t]))};
J[3][x_,t_]:=Module[{Jumps,Domains,NumPts},
Jumps={
\[CapitalPhi]t[x,t][#].Ln[x,t][#].\[CapitalPhi]tin[x,t][#]&,
\[CapitalPhi]t[x,t][#].Ln[x,t][#].\[CapitalPhi]tin[x,t][#]&,
\[CapitalPhi]t[x,t][#].Un[x,t][#].\[CapitalPhi]tin[x,t][#]&,
\[CapitalPhi]t[x,t][#].Un[x,t][#].\[CapitalPhi]tin[x,t][#]&,
\[CapitalPhi]t[x,t][#].Mn[x,t][#].\[CapitalPhi]tin[x,t][#]&,
\[CapitalPhi]t[x,t][#].Mn[x,t][#].\[CapitalPhi]tin[x,t][#]&,
\[CapitalPhi]t[x,t][#].Pn[x,t][#].\[CapitalPhi]tin[x,t][#]&,
\[CapitalPhi]t[x,t][#].Pn[x,t][#].\[CapitalPhi]tin[x,t][#]&,
DDIn[#].\[CapitalPhi]tin[x,t][#]&,
DDn[#].Un[x,t][#].\[CapitalPhi]tin[x,t][#]&,
Linn[x,t][#].Mn[x,t][#].\[CapitalPhi]tin[x,t][#]&,
Linn[x,t][#].\[CapitalPhi]tin[x,t][#]&
};
Domains={
Line[{-el  - I \[Nu] ,MaxRadsn[x,t][[1]]Exp[-3I \[Pi]/4.]}],
Line[MaxRadsn[x,t]Exp[-3I \[Pi]/4.]],
Line[{-el + I \[Nu] ,MaxRadsn[x,t][[1]]Exp[3I \[Pi]/4.]}],
Line[MaxRadsn[x,t]Exp[3I \[Pi]/4.]],
Line[Reverse[MaxRadsn[x,t]]Exp[-I \[Pi]/4.]],
Line[{MaxRadsn[x,t][[1]]Exp[-I \[Pi]/4.],el - I \[Nu] }],
Line[Reverse[MaxRadsn[x,t]]Exp[I \[Pi]/4.]],
Line[{MaxRadsn[x,t][[1]]Exp[I \[Pi]/4.],el  + I \[Nu] }],
Line[{Exp[-3I \[Pi]/4],Exp[3I \[Pi]/4]}*MaxRadsn[x,t][[2]]],
Line[{Exp[3I \[Pi]/4],Exp[I \[Pi]/4]}*MaxRadsn[x,t][[2]]],
Line[{Exp[I \[Pi]/4],Exp[- I \[Pi]/4]}*MaxRadsn[x,t][[2]]],
Line[{Exp[-I \[Pi]/4],Exp[-3 I \[Pi]/4]}*MaxRadsn[x,t][[2]]]
};
Domains=Domains-x/(4t);
NumPts=Table[smallN,{i,1,12}];
NumPts[[1]]=bigN;
NumPts[[3]]=bigN;
NumPts[[6]]=bigN;
NumPts[[8]]=bigN;
{Jumps,Domains,NumPts}
];
Jsamp[3][x_,t_]:=Module[{Jumps,Domains,NumPts},
Jumps={
Lnsamp[x,t][#]&,
Lnsamp[x,t][#]&,
Unsamp[x,t][#]&,
Unsamp[x,t][#]&,
Mnsamp[x,t][#]&,
Mnsamp[x,t][#]&,
Pnsamp[x,t][#]&,
Pnsamp[x,t][#]&,
Lnsamp[x,t][#]&,
Lnsamp[x,t][#].Unsamp[x,t][#]&,
Lnsamp[x,t][#].Mnsamp[x,t][#]&,
Lnsamp[x,t][#]&
};
Domains={
Line[{-el  - I \[Nu] ,MaxRadsn[x,t][[1]]Exp[-3I \[Pi]/4.]}],
Line[MaxRadsn[x,t]Exp[-3I \[Pi]/4.]],
Line[{-el + I \[Nu] ,MaxRadsn[x,t][[1]]Exp[3I \[Pi]/4.]}],
Line[MaxRadsn[x,t]Exp[3I \[Pi]/4.]],
Line[Reverse[MaxRadsn[x,t]]Exp[-I \[Pi]/4.]],
Line[{MaxRadsn[x,t][[1]]Exp[-I \[Pi]/4.],el - I \[Nu] }],
Line[Reverse[MaxRadsn[x,t]]Exp[I \[Pi]/4.]],
Line[{MaxRadsn[x,t][[1]]Exp[I \[Pi]/4.],el  + I \[Nu] }],
Line[{Exp[-3I \[Pi]/4],Exp[3I \[Pi]/4]}*MaxRadsn[x,t][[2]]],
Line[{Exp[3I \[Pi]/4],Exp[I \[Pi]/4]}*MaxRadsn[x,t][[2]]],
Line[{Exp[I \[Pi]/4],Exp[- I \[Pi]/4]}*MaxRadsn[x,t][[2]]],
Line[{Exp[-I \[Pi]/4],Exp[-3 I \[Pi]/4]}*MaxRadsn[x,t][[2]]]
};
Domains=Domains-x/(4t);
NumPts=Table[smallN,{i,1,12}];
NumPts[[1]]=bigN;
NumPts[[3]]=bigN;
NumPts[[6]]=bigN;
NumPts[[8]]=bigN;
{Jumps,Domains,NumPts}
];
Jadapt[3][x_,t_]:=Adapt[Jsamp[3][x,t],globalTol][J[3][x,t]]


InvScale[x_,t_][k_]:=Sqrt[t](k+x/(4t));
Scaling[x_,t_][k_]:=k/Sqrt[t] -x/(4t);

(*not scaled*)
Tn[+1][x_,t_,a_,c_][z_]:=({
 {1, 0},
 {-c Exp[\[Theta][x,t][a]]/(z-a), 1}
});
Tn[-1][x_,t_,a_,c_][z_]:=({
 {1, \[Lambda] cc[-c Exp[\[Theta][x,t][a]]/(cc[z]-a)]},
 { 0, 1}
});
Sn[+1][x_,t_,a_,c_][z_]:=({
 {1, -(z-a)/c*Exp[-\[Theta][x,t][a]]},
 {0, 1}
});
Sn[-1][x_,t_,a_,c_][z_]:=({
 {1, 0},
 {\[Lambda] cc[-(cc[z]-a)/c*Exp[-\[Theta][x,t][a]]], 1}
});
ContourArrayn[+1,r_,a_]:={Arc[a,r,{0,Pi}],Arc[a,r,{Pi,2Pi}]};
ContourArrayn[-1,r_,a_]:={Arc[a//cc,r,{0,-Pi}],Arc[a//cc,r,{-Pi,-2Pi}]};

(* This is scaled*)
(*T[+1][x_,t_,a_,c_][z_]:=Tn[+1][x,t,a,c][Scaling[x,t][z]];
T[-1][x_,t_,a_,c_][z_]:=Tn[-1][x,t,a,c][Scaling[x,t][z]];
S[+1][x_,t_,a_,c_][z_]:=Sn[+1][x,t,a,c][Scaling[x,t][z]];
S[-1][x_,t_,a_,c_][z_]:=Sn[-1][x,t,a,c][Scaling[x,t][z]];*)


(*ContourArray[+1,r_,a_,x_,t_]:={Arc[InvScale[x,t][a],r*Sqrt[t],{0,Pi}],Arc[InvScale[x,t][a],r*Sqrt[t],{Pi,2Pi}]};
ContourArray[-1,r_,a_,x_,t_]:={Arc[InvScale[x,t][a//cc],r*Sqrt[t],{0,-Pi}],Arc[InvScale[x,t][a//cc],r*Sqrt[t],{-Pi,-2Pi}]};*)

PoleListn[x_,t_]:=Module[{out,i,Domain,Jumps,Points},
Domain={};
Jumps={};
Points={};
For[i=1,i<=Length[a],i++,
If[1/globalTol>Abs[c[[i]]]Exp[Re[\[Theta][x,t][a[[i]]]]]&&Abs[c[[i]]]Exp[Re[\[Theta][x,t][a[[i]]]]]> globalTol,
If[Abs[c[[i]]]Exp[Re[\[Theta][x,t][a[[i]]]]]>expconst,
Jumps=Join[Jumps,{Sn[+1][x,t,a[[i]],c[[i]]],Sn[+1][x,t,a[[i]],c[[i]]]}];
Jumps=Join[Jumps,{Sn[-1][x,t,a[[i]],c[[i]]],Sn[-1][x,t,a[[i]],c[[i]]]}];
flag="pos";
,
Jumps = Join[Jumps,{Tn[+1][x,t,a[[i]],c[[i]]],Tn[+1][x,t,a[[i]],c[[i]]]}];
Jumps = Join[Jumps,{Tn[-1][x,t,a[[i]],c[[i]]],Tn[-1][x,t,a[[i]],c[[i]]]}];
flag="neg";
];
Domain= Join[Domain,Join[ContourArrayn[+1,rad,a[[i]]],ContourArrayn[-1,rad,a[[i]]]]];
Points=Join[Points,{smallN,smallN,smallN,smallN}];
];
];
{Jumps,Domain,Points}
];
(*  This is not used and tol is not defined
PoleList[x_,t_]:=Module[{out,i,Domain,Jumps,Points},
Domain={};
Jumps={};
Points={};
For[i=1,i\[LessEqual]Length[a],i++,
If[1/tol >Abs[c[[i]]]Exp[Re[\[Theta][x,t][a[[i]]]]]> tol,
If[Abs[c[[i]]]Exp[Re[\[Theta][x,t][a[[i]]]]]>expconst,
Jumps=Join[Jumps,{S[+1][x,t,a[[i]],c[[i]]],Sn[+1][x,t,a[[i]],c[[i]]]}];
Jumps=Join[Jumps,{S[-1][x,t,a[[i]],c[[i]]],Sn[-1][x,t,a[[i]],c[[i]]]}];
flag="pos";,
Jumps = Join[Jumps,{T[+1][x,t,a[[i]],c[[i]]],Tn[+1][x,t,a[[i]],c[[i]]]}];
Jumps = Join[Jumps,{T[-1][x,t,a[[i]],c[[i]]],Tn[-1][x,t,a[[i]],c[[i]]]}];
flag="neg";
];
Domain= Join[Domain,Join[ContourArray[+1,rad,a[[i]]],ContourArray[-1,rad,a[[i]]]]];
Points=Join[Points,{smallN,smallN,smallN,smallN}];
];
];
{Jumps,Domain,Points}
];
*)


DomainIntegrate[0.]:=0;
tcrit=8;
NLS[i_][x_,t_]:=Module[{rhp1,rhp2,scale,\[CapitalPhi]1,\[CapitalPhi]2,\[CapitalPhi],out,t1,t2,t3,t4,poles},
If[i==2,scale=True,scale=False];
RHSolved//Clear;
RHSolved[X_]:=RHSolved[X]=RHSolve[X];
RHSolved[{}]:=0.;
RHSolution[X_][z_]:=Cauchy[X//RHSolved,z]+IdentityMatrix[2];

If[scale,
t1=Timing[rhp1=ConjugateList[Jadapt[i][x,t],Q[x,t]]//MakeListFun;];
(*Q is v(z) in the book, used to deal with soliton*)
t2=Timing[RHSolved[rhp1];];
\[CapitalPhi]1[k_]:=RHSolution[rhp1][InvScale[x,t][k]]//Inverse;
,
(*Unscaled contour*)
t1=Timing[rhp1=ConjugateList[Jadapt[i][x,t],Qn[x,t]]//MakeListFun;];
(*Grhp1=rhp1;
Grhp0=J[0][x,t]//MakeListFun;
out0=J[0][2,0]//MakeListFun;
out1=G[2,0];*)
domainOutput = DomainPlot[rhp1];
t2=Timing[RHSolved[rhp1];];
\[CapitalPhi]1[k_]:=RHSolution[rhp1][k]//Inverse;
];

rhp2= ConjugateList[PoleListn[x,t],Qn[x,t]];
(*Print[PoleListn[2,0]];*)
If[i>1,
rhp2= ConjugateList[rhp2,\[CapitalPhi]tin[x,t]];
];
t3=Timing[rhp2= ConjugateList[rhp2,\[CapitalPhi]1]//MakeListFun;];
domainOutput2 = DomainPlot[rhp2];
t4=Timing[RHSolved[rhp2];];
\[CapitalPhi]2 = RHSolution[rhp2];
\[CapitalPhi][k_]:=RHSolution[rhp2][k].RHSolution[rhp1][k];
out=-(DomainIntegrate[RHSolved[rhp1]] If[scale,1/Sqrt[t],1]+DomainIntegrate[RHSolved[rhp2]])[[1,2]]/Pi;
timestring= "Region: " <>ToString[i]<>" ("<>ToString[x]<>","<>ToString[t]<>") "<>"1) Construct: " <> ToString[t1//First]<>"  "<>"1) Solve: " <> ToString[t2//First]<>"  "<>"2) Construct: " <> ToString[t3//First]<>"  "<>"2) Solve: " <> ToString[t4//First];
If[timeflag,Print[timestring];];
{out,\[CapitalPhi],rhp1,rhp2,timestring}
];
NLSAuto[x_,t_]:=\[Piecewise]{
 {NLS[0][x,t][[1]], Abs[x]<=5&&t<.1},
 {NLS[2][x,t][[1]], t>tcrit},
 {NLS[1][x,t][[1]], True}
}



(*NLS[x_,t_]:=-DomainIntegrate[RHSolveTop[JNLS[x,t]]]\[LeftDoubleBracket]2\[RightDoubleBracket]/( \[Pi]\[NonBreakingSpace])*If[t>tcrit,1/Sqrt[t],1];
NLSSelect[i_][x_,t_]:=-DomainIntegrate[RHSolveTop[G[i][x,t]]]\[LeftDoubleBracket]2\[RightDoubleBracket]/( \[Pi]\[NonBreakingSpace])*If[i\[Equal]2,1/Sqrt[t],1];*)


End[];
